package com.huanghehua.www.framework.orm.handler;

import com.huanghehua.www.ioc.exception.ReflectionException;
import com.huanghehua.www.orm.exception.DataSourceException;
import com.huanghehua.www.orm.model.PreparedStatementConfiguration;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * SQL语句处理器的顶级接口，用于声明具体处理器中必要的方法.<br/>
 * <p/>
 * 每次调用CRUD操作时，都会进行拦截判断传入的实参类型，从而选择不同的SQL处理器。<br/>
 * 主要的两种处理器为mapSqlHandler和objectSqlHandler<br/>
 *
 * @author silent_child
 * @version 1.0
 **/

public class SqlHandler {
    private static final Logger LOGGER = Logger.getLogger("com.huanghehua.www.framework.orm.handler.SqlHandler");
    /**
     * 核心方法，用于处理SQL语句，并将{@code parameters}中的数据赋值给PreparedStatement实例，最后返回该实例。<br/>
     *
     * @param parameters                     带有具体数据的实例
     * @param preparedStatementConfiguration 包含了创建所需要的参数
     * @return {@link PreparedStatement}
     * @throws SQLException 直接向上抛出
     */
    public static <T> PreparedStatement handle(PreparedStatementConfiguration preparedStatementConfiguration, T parameters) throws SQLException {
        if (parameters instanceof Map) {
            return SqlHandler.mapSqlHandler(preparedStatementConfiguration, parameters);
        }
        else {
            return SqlHandler.objectSqlHandler(preparedStatementConfiguration, parameters);
        }
    }

    /**
     * sql处理程序
     * 传入连接资源、sql语句以及含有特定数据的Map实例来为操作数据库数据进行准备，
     * 调用该方法将返回一个可以立即执行的{@link PreparedStatement}实例。<br/>
     * <p/>
     * 该方法将调用{@code parsePrototypeSql()}方法获取一个解析后的SQL，
     * 再通过该SQL与连接资源和Object实例资源配合进行操作。<br/>
     *
     * @param parameters           含有特定数据，即为占位符"?"传值的数据。K为占位符"#{}"中的字面量值，即属性名，V为要传入的实参值
     * @param preparedStatementConfiguration 包含了创建所需要的参数
     * @return {@link PreparedStatement}
     * @throws SQLException 直接向上抛出
     */
    private static <T> PreparedStatement mapSqlHandler(PreparedStatementConfiguration preparedStatementConfiguration,
                                    T parameters) throws SQLException {
        Map<String, Object> parametersMap = (Map<String, Object>) parameters;
        /*获取所需参数*/
        String prototypeSql = preparedStatementConfiguration.getPrototypeSql();
        Connection connection = preparedStatementConfiguration.getConnection();
        int autoGeneratedKeys = preparedStatementConfiguration.getAutoGeneratedKeys();

        /*获取解析后的sql语句*/
        // 调用接口的默认方法
        String sql = SqlHandlerUtil.parsePrototypeSql(prototypeSql);

        /*接下来解析原生sql中相关占位符中的对象属性信息保存在Map集合中*/
        // 调用接口的默认方法
        Map<Integer, String> field = SqlHandlerUtil.fieldMap(prototypeSql);

        /*将解析好的sql结合先前解析得到的Map集合为占位符"?"进行赋值*/
        // 创建preparedStatement实例
        PreparedStatement preparedStatement = connection.prepareStatement(sql, autoGeneratedKeys);
        // 遍历，通过两个Map集合为每一个占位"?"进行赋值
        field.forEach((index, fieldName) -> {
            try {
                // 得到需要传入的值
                Object obj = parametersMap.get(fieldName);
                // 给sql语句中的占位符?赋值
                preparedStatement.setObject(index, obj);

            } catch (SQLException e) {
                LOGGER.log(Level.SEVERE, "为preparedStatement的占位符赋值失败" + e);
                throw new DataSourceException("为preparedStatement的占位符赋值失败" + e);
            }
        });

        return preparedStatement;
    }

    /**
     * sql处理程序
     * 传入连接资源、sql语句以及含有特定数据的pojo实例来为操作数据库数据进行准备，
     * 调用该方法将返回一个可以立即执行的{@link PreparedStatement}实例。<br/>
     * <p/>
     * 该方法将调用{@code parsePrototypeSql()}方法获取一个解析后的SQL，
     * 再通过该SQL与连接资源和Object实例资源配合进行操作。<br/>
     *
     * @param parameters           含有特定数据，即为占位符"?"传值的数据
     * @param preparedStatementConfiguration 包含了创建所需要的参数
     * @return {@link PreparedStatement}
     * @throws SQLException 直接向上抛出
     */
    private static PreparedStatement objectSqlHandler(PreparedStatementConfiguration preparedStatementConfiguration,
                                    Object parameters) throws SQLException {
        /*获取所需参数*/
        String prototypeSql = preparedStatementConfiguration.getPrototypeSql();
        Connection connection = preparedStatementConfiguration.getConnection();
        int autoGeneratedKeys = preparedStatementConfiguration.getAutoGeneratedKeys();

        // 获取parameters的运行类型
        Class<?> parametersClass = parameters.getClass();

        /*接下来开始解析原生sql为符合JDBC规范的sql语句*/
        // 调用接口的默认方法
        String sql = SqlHandlerUtil.parsePrototypeSql(prototypeSql);

        /*接下来解析原生sql中相关占位符中的对象属性信息保存在Map集合中*/
        // 调用接口的默认方法
        Map<Integer, String> field = SqlHandlerUtil.fieldMap(prototypeSql);


        /*将解析好的sql结合先前解析得到的Map集合为占位符"?"进行赋值*/
        // 用于拼接po类获取字段值的方法名
        final String get = "get";
        // 创建preparedStatement实例
        PreparedStatement preparedStatement = connection.prepareStatement(sql, autoGeneratedKeys);
        // 遍历，通过反射为每一个占位"?"进行赋值
        field.forEach((index, fieldName) -> {
            // 每一个占位符中的字段的get方法名
            String getMethodName = get + (char) (fieldName.charAt(0) - 32) + fieldName.substring(1);
            try {
                // 通过反射获取get方法
                Method getMethod = parametersClass.getDeclaredMethod(getMethodName);
                // 调用get方法得到obj中的私有属性，然后给sql语句中的占位符?赋值
                Object invoke = getMethod.invoke(parameters);
                preparedStatement.setObject(index, invoke);

            } catch (SQLException e) {
                LOGGER.log(Level.SEVERE, "为preparedStatement的占位符赋值失败", e);
                throw new DataSourceException("为preparedStatement的占位符赋值失败", e);
            }
            catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                LOGGER.log(Level.SEVERE, "反射调用方法出错", e);
                throw new ReflectionException("反射调用方法出错", e);
            }
        });

        // 返回赋完值的preparedStatement实例
        return preparedStatement;
    }


}
