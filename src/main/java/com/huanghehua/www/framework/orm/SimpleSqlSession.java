package com.huanghehua.www.framework.orm;

import com.huanghehua.www.orm.annotation.SimpleSql;
import com.huanghehua.www.orm.exception.QueryException;
import com.huanghehua.www.orm.exception.ReflectionException;
import com.huanghehua.www.orm.handler.JdbcResultSetHandler;
import com.huanghehua.www.orm.handler.SqlHandler;
import com.huanghehua.www.orm.model.MetaMapperStatement;
import com.huanghehua.www.orm.model.PreparedStatementConfiguration;
import com.huanghehua.www.orm.model.SqlAnnotationInfo;

import java.sql.*;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * 该sql会话主要用于对数据库进行一系列的操作。集成了操作数据库必要的功能。<br/>
 * <p/>
 * 其中{@code close()},{@code commit()},{@code rollback()}方法主要在service层被调用。<br/>
 * 其中有关CRUD的操作均在dao层被调用。<br/>
 * 该类中的异常均向上抛出，交由调用者进行处理。<br/>
 * SqlSession的作用域应该是局部的，即用完就应该销毁。<br/>
 * 如果外界调用了无参构造器{@code SimpleSqlSession()}，
 * 那么应该再次调用{@code createSimpleSqlSession()}方法以获取一个完整的会话类实例。<br/>
 *
 * @author silent_child
 * @version 1.0
 **/
public class SimpleSqlSession implements SqlSession {
    /**
     * 每一个sqlSession实例将拥有{@link SimpleSqlSessionFactory}类中所有SQL语句映射的访问权限。
     * K为sql语句全限定id，V为包含标签信息的对象
     */
    private final Map<String, MetaMapperStatement> statementMap;
    /**
     * 每一个SqlSession实例都将持有一个<strong>唯一</strong>的事务管理器，用于管理事务相关的操作。
     */
    private final Transaction transaction;
    /**
     * 从transaction实例中获取到的连接资源，对于每一个会话类，应该仅持有<strong>唯一</strong>的一份连接资源，
     * 并通过该连接资源完成整个会话关于数据库的操作，而不应该频繁的通过transaction对连接资源进行获取或者关闭。
     */
    private Connection connection;

    /**
     * 每个线程都将可以在程序中绑定一些资源，这些资源来自于{@link SimpleSql}.<br/>
     * 当不存在指定资源时，默认为空
     */
    private final SqlAnnotationInfo sqlSqlAnnotationInfo = new SqlAnnotationInfo();

    /**
     * 创建一个SqlSession对象，可以进行都数据库的操作。
     *
     * @param transaction  事务管理器
     * @param statementMap 包含SQL映射语句的集合
     */
    public SimpleSqlSession(Transaction transaction, Map<String, MetaMapperStatement> statementMap) {
        this.transaction = transaction;
        this.statementMap = statementMap;
    }


    /**
     * 用于关闭会话。<br/>
     * <p/>
     * 内部将会把连接释放。
     */
    @Override
    public void close() throws SQLException {
        transaction.close();
    }

    /**
     * 提交事务。
     */
    @Override
    public void commit() throws SQLException {
        transaction.commit();
    }

    /**
     * 回滚事务。
     */
    @Override
    public void rollback() throws SQLException {
        transaction.rollback();
    }

    /**
     * 用于插入parameters对象记录，返回受影响行数。
     * <p/>
     * 调用本类中的{@code update()}方法进行添加操作。<br/>
     *
     * @param sqlId      sql语句的一个映射，即sql语句的位置。
     * @param parameters 需要插入的对象
     * @return int 返回受影响行数
     */
    @Override
    public int insert(String sqlId, Object parameters) throws SQLException {
        return update(sqlId, parameters);
    }

    /**
     * 用于删除parameters对象记录，返回受影响行数。
     * <p/>
     * 调用本类中的{@code update()}方法进行删除操作。<br/>
     *
     * @param sqlId      sql语句的一个映射，即sql语句的位置。
     * @param parameters 需要删除的对象
     * @return int 返回受影响行数
     */
    @Override
    public int delete(String sqlId, Object parameters) throws SQLException {
        return update(sqlId, parameters);
    }

    /**
     * 更新, 调用此方法时绝不会返回自增主键
     *
     * @param sqlId      sql id
     * @param parameters 参数
     * @return int 返回受影响行数
     * @throws SQLException sqlexception异常
     */
    @Override
    public int update(String sqlId, Object parameters) throws SQLException {
        return this.update(sqlId, parameters);
    }

    /**
     * 用于更新parameters对象记录，返回受影响行数，或者自增主键。<br/>
     * <p/>
     * 将自动开启连接。<br/>
     * 该方法作为dml的核心方法，本类中的{@code insert()}和{@code delete()}方法都将调用该方法执行dml操作。<br/>
     * 该方法将statement，即sql映射位置传给{@code parseStatement()}方法，以便得到JDBC标准slq语句。<br/>
     * 该方法主要将xml文件中的原生sql语句再一次解析得到占位符"#{}"中的字段名，
     * 通过这些字段名来得知该对JDBC的占位符?赋上obj中的哪些字段值。<br/>
     * <p/>
     * 注意，因为在为占位符"?"赋值时，使用的均是{@code setString()}方法，故不能传入一个null作为值。<br/>
     *
     * @param sqlId             sql语句的一个映射，即sql语句的位置。
     * @param parameters        需要更新的对象
     * @param autoGeneratedKeys 自增主键
     * @return int 返回受影响行数，或者自增主键
     * @throws SQLException sqlexception异常
     */
    @Override
    public int update(String sqlId, Object parameters, int autoGeneratedKeys) throws SQLException {
        // 获取对应的原生SQL语句
        String prototypeSql;

        // 获取对应的原生SQL语句
        prototypeSql = this.sqlSqlAnnotationInfo.getSql();
        // 为null则按xml配置文件为准
        if (prototypeSql == null) {
            // 根据全限定id，即statement获取对应的SQL映射对象
            MetaMapperStatement metaMapperStatement = statementMap.get(sqlId);
            // 获取对应的原生SQL语句
            prototypeSql = metaMapperStatement.getPrototypeSql();
        }


        // 开启连接资源
        openConnection();
        /*封装数据*/
        PreparedStatementConfiguration preparedStatementConfiguration =
                new PreparedStatementConfiguration(connection, prototypeSql, autoGeneratedKeys);

        /*获取可以立即执行的preparedStatement实例,
          try-with-resources自动关闭资源
         */
        try (PreparedStatement preparedStatement = SqlHandler.handle(preparedStatementConfiguration, parameters)) {
            int rowCount = preparedStatement.executeUpdate();

            // 查看是否需要返回主键
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
                ResultSet rs = preparedStatement.getGeneratedKeys();
                rs.next();
                LOGGER.log(Level.INFO, "记录更新成功， 并返回主键");
                return rs.getInt(1);
            }

            LOGGER.log(Level.INFO, "记录更新成功");
            // 执行sql语句, 并返回受影响行数
            return rowCount;
        }
    }

    /**
     * 用于查询parameters对象记录，返回查询得到的对象。
     * <p/>
     * 将自动开启连接。<br/>
     * 当查询无果时返回null。<br/>
     * 当查询结果数量大于1时，抛出异常。<br/>
     * 当且仅当查询结果为1个时，返回查询对象。<br/>
     *
     * @param sqlId      sql语句的一个映射，即sql语句的位置。
     * @param parameters 需要查询的对象
     * @param <T>        泛型，用于限定查询结果的元素类型
     * @return T 指定元素类型的对象
     * @throws SQLException 直接向上抛出
     */
    @Override
    public <T> T selectOne(String sqlId, Object parameters) throws SQLException {
        // 接收结果集合
        List<Object> objects = selectList(sqlId, parameters);

        if (objects.size() == 0) {
            LOGGER.log(Level.INFO, "查询记录不存在");
            throw new QueryException("查询记录不存在");
        }
        else if (objects.size() > 1) {
            LOGGER.log(Level.INFO, "查询记录不唯一");
            throw new QueryException("查询记录不唯一");
        }

        LOGGER.log(Level.INFO, "查询唯一记录成功");
        return (T) objects.get(0);
    }

    /**
     * 用于查询parameters对象记录，返回查询得到的所有对象.<br/>
     * <p/>
     * 将自动开启连接。<br/>
     *
     * @param sqlId      SQL语句的全限定id
     * @param parameters 查询的对象
     * @return {@link List}<{@link E}> 存放着封装了结果集数据的指定元素E的List集合
     * @throws SQLException 直接向上抛出
     */
    @Override
    public <E> List<E> selectList(String sqlId, Object parameters) throws SQLException {
        // 获取原始SQL
        String prototypeSql;
        // 获取对应返回值类型的Class对象
        Class<?> resultType;

        // 获取Sql
        prototypeSql = this.sqlSqlAnnotationInfo.getSql();
        // 不为null就以构建的SQL为准进行操作数据库
        if (prototypeSql != null) {
            resultType = this.sqlSqlAnnotationInfo.getResultType();
        }
        // 否则以xml配置文件的为准进行操作数据库
        else {
            // 获取SQL映射对象
            MetaMapperStatement metaMapperStatement = statementMap.get(sqlId);

            if (metaMapperStatement == null) {
                LOGGER.log(Level.SEVERE, "sqlId don't exist");
                throw new NullPointerException("sqlId don't exist");
            }
            
            // 获取SQL返回值类型
            String type = metaMapperStatement.getResultType();

            // 创建对应返回值类型的Class对象
            try {
                resultType = Class.forName(type);
            } catch (ClassNotFoundException e) {
                LOGGER.log(Level.WARNING, "创建对应返回值类型的Class对象", e);
                throw new ReflectionException("创建对应返回值类型的Class对象", e);
            }

            // 获取原始SQL
            prototypeSql = metaMapperStatement.getPrototypeSql();

        }

        // 开启连接
        openConnection();
        /*封装数据*/
        PreparedStatementConfiguration preparedStatementConfiguration =
                new PreparedStatementConfiguration(connection, prototypeSql);

        // 获取preparedStatement实例，并自动关闭
        try (PreparedStatement preparedStatement = SqlHandler.handle(preparedStatementConfiguration, parameters);
             ResultSet resultSet = preparedStatement.executeQuery()) {

            List<E> res = JdbcResultSetHandler.handleToList(resultSet, resultType);


            LOGGER.log(Level.INFO, "查询指定记录成功");
            return res;
        }

    }

    /**
     * 公开方法，需要调用本类的方法时，都应该先确保打开连接资源。<br/>
     *
     * @throws SQLException 直接向上抛出异常不做处理
     */
    public void openConnection() throws SQLException {
        if (connection == null) {
            connection = transaction.getConnection();
            LOGGER.log(Level.INFO, "开启连接成功");
        }
        else {
            LOGGER.log(Level.INFO, "连接已存在");
        }
    }

    private static final Logger LOGGER = Logger.getLogger("com.huanghehua.www.framework.orm.SimpleSqlSession");
}
